= Install and Start Using the Scala SDK with Couchbase Server
:description: Get up and running quickly, installing the Couchbase Scala SDK, and running our Hello World example.
:navtitle: Start Using the SDK
:page-topic-type: howto
:page-aliases: ROOT:getting-started,ROOT:start-using,ROOT:hello-couchbase,ROOT:start-using-sdk
:lang: Scala
:page-toclevels: 2

include::project-docs:partial$attributes.adoc[]

[abstract]
{description}

The Couchbase Scala SDK allows Scala applications to access a Couchbase cluster.

== Hello Couchbase

On this page we show you how to quickly get up and running -- installing the Couchbase Scala SDK, and trying out the _Hello World_ code example against Couchbase Capella, or against a local Couchbase cluster.

We will go through the code sample step by step, but for those in a hurry to see it, here it is:

[{tabs}] 
==== 
Couchbase Capella Sample::
+
--
[source,scala]
----
include::example$Cluster.scala[tag=imports]
object CloudClusterExample {
  def cloudConnect(): Unit = {
include::example$Cluster.scala[tag=cloud-cluster]

  }

  def main(args: Array[String]): Unit = {
    cloudConnect()
  }
}

object ClusterExample {
  def main(args: Array[String]) {
include::example$Cluster.scala[tag=resources]
include::example$Cluster.scala[tag=json]
include::example$Cluster.scala[tag=upsert]
include::example$Cluster.scala[tag=get]
    def getFor() {
include::example$Cluster.scala[tag=get-for]
    def getMap() {
include::example$Cluster.scala[tag=get-map]
    def replaceOptions() {
include::example$Cluster.scala[tag=replace-options]
    }

    def replaceNamed() {
include::example$Cluster.scala[tag=replace-named]
    }
  }
}
----
--

Local Couchbase Server::
+
--
[source,scala]
----
include::example$Cluster.scala[tag=imports]
object ClusterExample {
  def main(args: Array[String]) {
include::example$Cluster.scala[tag=cluster]
include::example$Cluster.scala[tag=resources]
include::example$Cluster.scala[tag=json]
include::example$Cluster.scala[tag=upsert]
include::example$Cluster.scala[tag=get]
    def getFor() {
include::example$Cluster.scala[tag=get-for]
    def getMap() {
include::example$Cluster.scala[tag=get-map]
    def replaceOptions() {
include::example$Cluster.scala[tag=replace-options]
    }

    def replaceNamed() {
include::example$Cluster.scala[tag=replace-named]
    }
  }
}
----
--
====


== Quick Install

A more detailed guide in our xref:project-docs:sdk-full-installation.adoc[Installation page] covers every supported platform, but this section should be enough to get up and running in most cases.

[{tabs}] 
==== 
SBT::
+
--
[source,sbt]
----
libraryDependencies += "com.couchbase.client" %% "scala-client" % "1.3.0"
----

This will automatically use the Scala 2.12 or 2.13 builds, as appropriate for your SBT project.
--

Gradle::
+
--
It can be included in your `build.gradle` like this for 2.13:

[source,groovy]
----
dependencies {
    compile group: 'com.couchbase.client', name: 'scala-client_2.13', version: '1.3.0'
}
----

For Scala 2.12, refer to the full xref:project-docs:sdk-full-installation.adoc[Installation page].
--

Maven::
+
--
It can be included in your Maven `pom.xml` like this for 2.13:

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>com.couchbase.client</groupId>
        <artifactId>scala-client_2.13</artifactId>
        <version>1.3.0</version>
    </dependency>
</dependencies>
----

For Scala 2.12, refer to the full xref:project-docs:sdk-full-installation.adoc[Installation page].
--
====



== Step by Step

Here's the above Hello World example, broken down into individual actions.

=== Connecting to a Cluster

Now you have the Scala client installed, try out the following to connect to a Couchbase cluster.

First pull in all the imports we'll be using:
[source,scala]
----
include::example$Cluster.scala[tag=imports,indent=0]
----

Now we can connect to the cluster:

[{tabs}]
====
Local Couchbase Server::
+
--
[source,scala]
----
include::example$Cluster.scala[tag=cluster,indent=0]
----

Of course, you'll need to change the IP address to match your own cluster's.
--

Couchbase Capella::
+
--
You connect to a https://docs.couchbase.com/cloud/index.html[Couchbase Capella] cluster the same as any other cluster, except that the use of TLS and a certificate is mandatory, and the "couchbases://" connection string prefix should be used to allow DNS SRV lookup.

If you are connecting to Capella rather than a local Couchbase Server, then also refer to the <<cloud-connections, Cloud section>>, below.

[source,scala]
----
include::example$Cluster.scala[tag=cloud-cluster,indent=0]
----
--
====

NOTE: `Cluster.connect` returns a `Try[Cluster]`, as the Scala client uses functional error handling and does not throw exceptions.
You'll see examples later of how to better handle a `Try`, but for simplicity here we'll assume the operation succeeded and get the result as a `Cluster` using `.get`.

Couchbase uses xref:{version-server}@server:learn:security/roles.adoc[Role Based Access Control (RBAC)] to control access to resources, so specify the username and password of a user you've setup during installation of the Couchbase Data Platform.

Now we can open a Couchbase bucket, and its default collection:

[source,scala]
----
include::example$Cluster.scala[tag=resources,indent=0]
----

The Scala SDK supports the new features of _scopes_ and
_collections_ in Couchbase Server 7.0. These allow documents to be grouped in a more granular way than buckets.

If you do not refer to a named collection, you can access the 'default collection', which includes all documents in a bucket, and is forwards and backwards compatible
with all supported versions of Couchbase Server.

`waitUntilReady` is an optional call.
Opening resources such as buckets is asynchronous -- that is, the `cluster.bucket` call returns immediately and proceeds in the background.
`waitUntilReady` ensures that the bucket resource is fully loaded before proceeding.
If not present, then the first Key Value (KV) operation on the bucket will wait for it to be ready.
As with `Cluster.connect`, we use `.get` on the result here for simplicity: see the xref:howtos:managing-connections.adoc[Managing Connections] page for a more complete example including functional error-handling.

=== JSON
Now we can do some simple Key Value operations.  First, let's create some JSON.

The Scala SDK directly supports several popular JSON libraries, including https://github.com/lihaoyi/upickle[uPickle/uJson], https://circe.github.io/circe/[Circe], https://github.com/playframework/play-json[Play Json], https://github.com/typelevel/jawn[Jawn], and https://github.com/json4s/json4s[Json4s] (if you'd like to see your favourite supported, please let us know).
In addition you can supply JSON encoded into a `String` or `Array[Byte]`, opening the door to any JSON library; https://jsoniter.com/[Jsoniter] and https://github.com/FasterXML/jackson[Jackson] have been tested this way, but any should work.

You can also directly encode and decode Scala case classes to and from the SDK.

To make things easy and to help get you started, the Scala SDK also bundles a home-grown small JSON library, which you are free to use instead of or alongside any of the other supported JSON libraries.
The philosophy behind this library is to provide a very easy-to-use API and the fastest JSON implementation possible.

These options are described in detail xref:howtos:json.adoc[here], but to get us started let's created some simple JSON using the built-in JsonObject library:

[source,scala]
----
include::example$Cluster.scala[tag=json,indent=0]
----

=== Key-Value Operations
And now let's upsert it into Couchbase (upsert is an operation that will insert the document if it does not exist, or replace it if it does).
We need to provide a unique ID for the JSON, and we'll use a UUID here:

[source,scala]
----
include::example$Cluster.scala[tag=upsert,indent=0]
----

As mentioned above, the Scala SDK will not throw exceptions.
Instead, methods that can error - such as the `upsert` above - will return a Scala `Try` result, which can either be a `Success` containing the result, or a `Failure` containing a _Throwable_ exception.
The easiest way to handle a single operation is with pattern matching, as shown above.

Now let's get the data back (this example will look a little messy due the the nested handling of multiple `Try` results, but we'll see how to clean it up shortly):

[source,scala]
----
include::example$Cluster.scala[tag=get,indent=0]
----

Here we're fetching the value for the key `docId`, converting that value to a `JsonObjectSafe` (a simple wrapper around `JsonObject` that returns `Try` results - see xref:howtos:json.adoc#error-handling-and-jsonobjectsafe[here] for details), and then accessing the value of the *status* key as a String.

=== Better Error Handling
All three of these operations could fail, so there's quite a lot of error handling code here to do something quite simple.
One way to improve on this is by using flatMap, like this:

[source,scala]
----
include::example$Cluster.scala[tag=get-map,indent=0]
----

Alternatively, you can use a for-comprehension, like so:

[source,scala]
----
include::example$Cluster.scala[tag=get-for,indent=0]
----

Either of these methods will stop on the first failed operation.  So the final returned `Try` contains either a) `Success` and the result of the final operation, indicating that everything was successful, or b) `Failure` with the error returned by the first failing operation.

=== Overloads
You'll notice that most operations in the Scala SDK have two overloads.
One will take an Options builder, which provides all possible options that operation takes.
For instance:
[source,scala]
----
include::example$Cluster.scala[tag=replace-options,indent=0]
----
These options blocks are implemented as Scala case classes, e.g. they are immutable data objects that return a copy of themselves on each change.

The other overload is provided purely for convenience.  It takes named arguments instead of an Options object, and provides only the most commonly used options:
[source,scala]
----
include::example$Cluster.scala[tag=replace-named,indent=0]
----

== Next Steps
You now know the basics of connecting to a Couchbase cluster, creating some JSON, and performing Key-Value operations, using the Scala SDK.

Key-Value operations are described in detail xref:scala-sdk:howtos:kv-operations.adoc[here].

For performing operations against multiple documents, check out how to use N1QL in Scala xref:scala-sdk:howtos:n1ql-queries-with-sdk.adoc[here].

The Scala SDK includes three APIs.  The examples above show the simple blocking API, for simplicity, but you can also perform all operations in an async style using Scala `Future`, and a reactive style using Project Reactor `SMono` and `SFlux`.
Please see xref:concurrent-async-apis[Choosing an API] for more details.

API reference are available in a scaladocs jar alongside the release.
